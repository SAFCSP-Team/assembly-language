# Assemblr
 
**Assemblr** is a program that is designed to  translate  assembly language into machine code. It supports a variety of assembly syntax styles, including the two most widely used formats: **Intel Syntax** and **AT&T Syntax**.
Assemblr ensures compatibility across multiple architectures, including **x86**, **x86_64**, and **ARM**.  

- **Assembly Language:** Low-level human-readable programming language.
Example:  
```asm
mov eax, ebx ; Move data from EBX to EAX
```
- **Machine Code:** Binary instructions (0s and 1s) executed by the CPU.
Example:
binary representation of the same instruction
```
1000100110000011 
```

## Syntax Style  
Assembly syntax determines how instructions, registers, and memory references are written. The two commonly used syntax styles are **Intel** and **AT&T**.  

### **Intel Syntax**  
- Widely used in **Windows environments**.  
- Commonly used by assemblers such as **MASM**, **NASM**, and **FASM**.  
- Known for its **readability** and logical operand ordering: **destination first, source second**.  

### **AT&T Syntax**  
- Used by **GAS (GNU Assembler)** in **Linux/Unix environments**.  
- Default syntax for assembly code generated by GCC.  
- Operands are written in **source, destination** order, and registers are prefixed with `%`.  



## Intel Syntax  

Intel syntax is the default choice for Windows-based assemblers.  
 
- **Operand Order**:  
   - **Destination, Source**  
   - The first operand is the destination, and the second is the source.  
   - Example: `mov eax, ebx` (move the value in `ebx` to `eax`).  

- **Memory Access**:  
   - Memory locations are enclosed in brackets (`[]`).  
   - Example: `mov eax, [var]` (load the value from memory address `var` into `eax`).  

- **No Register Prefix**:  
   - Registers are written without a prefix, e.g., `eax`, `ebx`.  

- **Instructions**:  
   - Mnemonics like `mov`, `add`, `sub`, and `jmp` are used.  


### Example 
Add two numbers stored in memory and store the result in a register:  

```asm
section .data
    num1 dd 5          ; Define a 32-bit integer with value 5
    num2 dd 10         ; Define a 32-bit integer with value 10

section .text
global _start

_start:
    mov eax, [num1]    ; Load the value of num1 into eax
    add eax, [num2]    ; Add the value of num2 to eax
    mov [num1], eax    ; Store the result back in num1
    ret
```  


## AT&T Syntax  

AT&T syntax is the default for GNU assembler (GAS) and is commonly used in Linux environments.  
  
- **Operand Order**:  
   - **Source, Destination**  
   - The first operand is the source, and the second is the destination.  
   - Example: `movl %ebx, %eax` (move the value in `%ebx` to `%eax`).  

- **Register Prefix**:  
   - Registers are prefixed with `%`, e.g., `%eax`, `%ebx`.  

- **Immediate Values**:  
   - Immediate values are prefixed with `$`.  
   - Example: `$5` represents the constant value `5`.  

- **Memory Access**:  
   - Memory addresses are referenced directly, e.g., `movl num1, %eax`.  
   - Indirect addressing uses parentheses, e.g., `(%eax)`.  


### Example  
Add two numbers stored in memory and store the result in a register

```asm
.section .data
num1: .long 5         # Define a 32-bit integer with value 5
num2: .long 10        # Define a 32-bit integer with value 10

.section .text
.global _start

_start:
    movl num1, %eax   # Load the value of num1 into %eax
    addl num2, %eax   # Add the value of num2 to %eax
    movl %eax, num1   # Store the result back in num1
    ret
```  

## Popular x86 Assemblers

| Assembler | Syntax Style | Platform      | Notes                     |
|-----------|--------------|---------------|---------------------------|
| NASM      | Intel        | Windows/Linux | Open source, widely used  |
| MASM      | Intel        | Windows       | Microsoft Macro Assembler |
| GAS       | AT&T         | UNIX/Linux    | GNU Assembler             |


